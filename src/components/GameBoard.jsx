import { useState } from "react";

const initialGameBoard = [
  [null, null, null],
  [null, null, null],
  [null, null, null],
];

export default function GameBoard({ onSelectSquare, turns }) {
  let gameBoard = initialGameBoard;

  for (const turn of turns) {
    const { square, player } = turn;
    const { row, col } = square;

    gameBoard[row][col] = player;
  }
  // const [gameBoard, setGameBoard] = useState(initialGameBoard);

  // function handleSelectSquare(rowIndex, colIndex) {
  //   setGameBoard((prevGameBoard) => {
  //     const updatedBoard = [...prevGameBoard.map((innerArray) => [...innerArray])];

  //     /*Тъй като тук имам работа с масив от масиви (или матрица), те също трябва да бъдат копирани,
  //     преди да актуализираме каквото и да било. Можем да постигнем това, като извикаме метода map върху
  //     старото ни състояние, т.е. върху стария ни масив тук. Така че тук имаме нашите вътрешни масиви,
  //     а за всеки вътрешен масив връщаме и нов вложен масив, който разпределя елементите на този вътрешен
  //     масив вътре в него. Така че технически тук имаме чисто нов масив, пълен с чисто нови вложени масиви,
  //     които все още съхраняват данните, които са съхранявали преди, но сега това е този актуализиран
  //     борд, който трябва да бъде актуализиран тук и който трябва да бъде върнат.
  //     Чрез този подход и модел ние актуализираме състоянието по неизменен начин, което е силно препоръчително
  //     поради причините, споменати по-долу. */

  //     updatedBoard[rowIndex][colIndex] = activePlayerSymbol;
  //     return updatedBoard;
  //   });

  //   onSelectSquare();

  //   /* Точно както трябва да използвате тази функция за актуализиране на състоянието, когато актуализирате
  //   състоянието си въз основа на някакво предишно състояние, също така е силно препоръчително, ако състоянието ви е
  //   обект или масив, да актуализирате това състояние по неизменен начин (да не се пипа оригиналния обект),
  //   което просто означава, че първо създавате копие на старото състояние, т.е. нов обект или нов масив, и след това
  //   просто променяте това копие вместо съществуващия обект или масив.
  //   Причината за тази препоръка е, че ако състоянието ви е обект или масив, в JavaScript имате работа с референтна стойност.
  //   Затова, ако го актуализирате по този начин, ще актуализирате старата стойност в паметта незабавно, дори преди
  //   планираното актуализиране на състоянието да бъде изпълнено от React. И това отново може да доведе до странни
  //   грешки или странични ефекти, ако имате няколко места в приложението, които планират актуализации на
  //   състоянието за едно и също състояние. */
  // }

  return (
    <ol id="game-board">
      {gameBoard.map((row, rowIndex) => (
        <li key={rowIndex}>
          <ol>
            {row.map((col, colIndex) => (
              <li key={colIndex}>
                <button onClick={() => onSelectSquare(rowIndex, colIndex)}>{col}</button>
              </li>
            ))}
          </ol>
        </li>
      ))}
    </ol>
  );
}
